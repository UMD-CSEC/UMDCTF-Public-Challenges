package ctf.malware.wtf.server.service;

import ctf.malware.wtf.server.schema.Config;
import ctf.malware.wtf.server.schema.Token;
import ctf.malware.wtf.server.schema.User;
import io.quarkus.arc.Unremovable;
import io.quarkus.runtime.annotations.RegisterForReflection;
import io.vertx.mutiny.pgclient.PgPool;
import io.vertx.mutiny.sqlclient.Query;
import io.vertx.mutiny.sqlclient.Row;
import io.vertx.mutiny.sqlclient.RowSet;
import org.flywaydb.core.Flyway;
import org.intellij.lang.annotations.Language;
import org.jboss.logging.Logger;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Clock;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.StreamSupport;

@Singleton
@RegisterForReflection
@Unremovable
public final class MigrationEngine {

    private static final Logger LOGGER = Logger.getLogger(MigrationEngine.class);

    @Inject
    public PgPool client;

    @Inject
    public Flyway flyway;

    MigrationEngine() {
    }

    public boolean hasMigrated() {
        return flyway.info().current().isVersioned();
    }

    public Flyway getFlyway() {
        return flyway;
    }

    public PgPool getClient() {
        return client;
    }

    public Query<RowSet<Row>> query(@Language("sql") final String sql) {
        return client.preparedQuery(sql);
    }

    public boolean doUserExistsQuery(final User user) {
        @Language("sql") String query = "select * from \"sessions\" where identifier = '%s'";
        return this
                .query(String.format(query, user.name))
                .execute()
                .onItemOrFailure()
                // toThrow (because I'm funny)
                .transform(transformRowWith((row) -> StreamSupport
                        .stream(row.spliterator(), false)
                        .anyMatch(r -> r.getString("identifier").equalsIgnoreCase(user.name)), (t) -> false)
                )
                .await()
                .indefinitely();
    }

    @Nullable
    public User getSession(final String token) {
        @Language("sql") String query = "select (\"user\")._name, ( \"user\")._token._expiry from active_sessions where (token)._plain = '%s'";
        return this
                .query(String.format(query, token))
                .execute()
                .onItemOrFailure()
                .transform(transformRowWith((row) -> StreamSupport
                        .stream(row.spliterator(), false)
                        .map(r -> {
                            String name = r.getString("_name");
                            LocalDateTime expiry = r.get(LocalDateTime.class, "_expiry");
                            User u = User.from(name, Config.CONFIG.getNode());
                            u.setExpiry(expiry.toEpochSecond(ZoneOffset.UTC));
                            return u;
                        }).findFirst().orElse(null), (err) -> null)
                )
                .await()
                .indefinitely();
    }

    public Token doAuthenticateQuery(final User user, final Token t) {
        Token token;
        token = Objects.requireNonNullElseGet(t, () -> Token.from(""));
        long time = user.getExpiry();
        @Language("sql") String query = "select * from authenticate_user('%s'::text, '%s'::text, to_timestamp(%d))";
        return this
                .query(String.format(query, user.name, token.token, time))
                .execute()
                .onItemOrFailure()
                .transform(transformRowWith((row) -> StreamSupport
                        .stream(row.spliterator(), false)
                        .map(r -> new Token(r.getString("_plain")))
                        .findFirst()
                        .orElse(token), (a) -> {
                    System.out.println(a.getMessage());
                    return null;
                }))
                .await()
                .indefinitely();
    }

    public long getExpiry(final Token token) {
        @Language("sql") final String query = "select * from get_expiry('%s')";
        return this
                .query(String.format(query, token.token))
                .execute()
                .onItemOrFailure()
                .transform(transformRowWith((r) -> StreamSupport
                        .stream(r.spliterator(), false)
                        .map(row -> row.get(LocalDateTime.class, 0))
                        .mapToLong(ldt -> ldt.toEpochSecond(ZoneOffset.UTC))
                        .findAny()
                        .orElse(0), (t) -> 0L
                ))
                .await()
                .indefinitely();
    }

    private static <T, R> BiFunction<T, Throwable, R> transformRowWith(final Function<T, R> onSuccess, final Function<Throwable, R> onError) {
        return (row, toThrow) -> {
            if (toThrow != null) {
                return onError.apply(toThrow);
            }
            return onSuccess.apply(row);
        };
    }

}
