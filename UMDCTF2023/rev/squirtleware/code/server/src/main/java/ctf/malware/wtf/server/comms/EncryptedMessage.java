package ctf.malware.wtf.server.comms;

import org.jetbrains.annotations.NotNull;

import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.function.Function;

public class EncryptedMessage extends Message {

    private static final String HEADER = "squirtleenespanol";
    private static final String END = "squirtleenespanol";
    private static final byte[] PADDING = {0, 0, 0, 0, 0, 0, 0, 0};

    public static Function<byte[], EncryptedMessage> getSupplier(final byte[] key) {
        return (bytes) -> EncryptedMessage.encrypt(Message.from(PlainMessage::new, bytes), key);
    }

    public static byte[] xor(final byte[] input, final byte[] key) {
        byte[] out = new byte[input.length];
        for (int i = 0; i < input.length; i++) {
            out[i] = (byte) (input[i] ^ key[i % key.length]);
        }
        return out;
    }


    public static EncryptedMessage encrypt(@NotNull final Message msg, final byte[] key) {
        byte[] headerBytes = HEADER.getBytes();
        byte[] endHeaderBytes = END.getBytes();
        byte[] data = msg.getData();
        // 1. [ client ] -> auth -> [ server ]
        // 2. [ server ] -> key -> [ client ]
        // 3. server acknowdges active client. key expires within like 20 min or something
        // 4. server <-> client messages are xor-ed w client key
        // 5. server <-> client messages are communicated through squirtle language
        // 6. Client has to intercept message and decrypt properly. Perhaps there's a flaw in client decryption?
        ByteBuffer buffer = ByteBuffer.allocate(
                headerBytes.length + PADDING.length + data.length + PADDING.length + endHeaderBytes.length
        );
        buffer.put(headerBytes).put(PADDING).put(xor(data, key)).put(PADDING).put(endHeaderBytes);
        byte[] packet = buffer.array();
        return new EncryptedMessage(packet, key);
    }

    private final byte[] key;

    public EncryptedMessage(final byte[] data, final byte[] key) {
        super(data);
        this.key = key;
    }

    public final byte[] getKey() {
        return this.key;
    }
}
