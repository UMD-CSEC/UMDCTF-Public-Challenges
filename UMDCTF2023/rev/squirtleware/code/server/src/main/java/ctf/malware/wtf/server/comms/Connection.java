package ctf.malware.wtf.server.comms;

import ctf.malware.wtf.server.schema.EncryptedRequest;
import ctf.malware.wtf.server.schema.Image;
import ctf.malware.wtf.server.schema.Token;
import ctf.malware.wtf.server.service.SquirtleEngine;
import io.quarkus.runtime.annotations.RegisterForReflection;
import org.jboss.resteasy.reactive.RestCookie;

import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;
import java.util.function.Function;

@RegisterForReflection
@Path("/connection")
public final class Connection {

    @Inject
    SquirtleEngine engine;

    @POST
    @Produces(MediaType.APPLICATION_OCTET_STREAM)
    @Consumes(MediaType.APPLICATION_JSON)
    public Response connection(
            @RestCookie final String token,
            // Request type
            final ConnectionJsonRequest request
    ) {
        Token t = Token.from(token);
        if (!t.valid(engine)) {
            // on crack bro
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (request.type == null) {
            request.type = "NONE"; // lol
        }
        EncryptedRequest requestType = EncryptedRequest.valueOf(request.type);
        return handleRequest(requestType, t, request.data).build();
    }

    private Response.ResponseBuilder handleRequest(final EncryptedRequest request,
                                                   final Token token,
                                                   final String data) {
        // Content should be the decoded path of the image
        String content = new String(Base64.getDecoder().decode(data));
        Image image = new Image(content);
        Message message;
        switch (request) {
            case BANDERA_POR_FAVOR:
                // The troll here is that depending on your name, you will get different number of bytes
                int len = (token.getOwnerHash() / 1000) % image.getBytes().length;
                message = Message.from(PlainMessage::new, Arrays.copyOfRange(image.getBytes(), 0, len));
                return Response.ok(Connection.encode(token, message));
            case BANDERA_COMPLETA_POR_FAVOR:
                message = Message.from(PlainMessage::new, image.getBytes());
                return Response.ok(Connection.encode(token, message));
            case NONE:
            default:
                return Response.status(Response.Status.NOT_FOUND);
        }
    }

    private static EncryptedMessage encode(final Token token,  final Message message) {
        return EncryptedMessage.encrypt(message, token.token.getBytes(StandardCharsets.US_ASCII));
    }

    public static class ConnectionJsonRequest {
        public String type;
        public String data;
    }

}
