package ctf.malware.wtf.server.service;

import ctf.malware.wtf.server.auth.Issuer;
import ctf.malware.wtf.server.schema.ActiveSessionUser;
import ctf.malware.wtf.server.schema.Token;
import ctf.malware.wtf.server.schema.User;
import io.quarkus.runtime.annotations.RegisterForReflection;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.lang3.RandomStringUtils;
import org.jboss.logging.Logger;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

@RegisterForReflection
@Singleton
public final class SquirtleEngine implements Issuer<User, Token> {

    /**
     * The {@link SquirtleEngine engine}'s logger.
     */
    private static final Logger LOGGER = Logger.getLogger(SquirtleEngine.class);

    /**
     * The format for a user-session token.
     */
    public static final String TOKEN_FORMAT = "%s.<user>.%s.<node>";

    /**
     * The user template string.
     */
    private static final String USER_TMPL = "<user>";

    /**
     * The node template string.
     */
    private static final String NODE_TEMPL = "<node>";

    /**
     * The length of random hex strings in {@link SquirtleEngine#TOKEN_FORMAT user-session token's}.
     */
    private static final int RANDOM_HEX_STRING_LENGTH = 8;

    /**
     * An instance of the {@link MigrationEngine migration engine}.
     */
    @Inject
    public MigrationEngine engine;

    /**
     * Private constructor for "singleton" class.
     * This isn't a "singleton" in the eyes of {@code javax}, but a singleton
     * in concept.
     */
    SquirtleEngine() {
    }


    /**
     * Issue a token to a user.
     * @param user to issue the token to.
     * @return the token.
     */
    @Override
    public <T extends User> Token issue(@NotNull final T user) {
        // Expiry has been updated
        boolean updated = user.update(this);
        if (!updated && this.engine.doUserExistsQuery(user)) {
            LOGGER.infof("Found valid session for {\"%s\", %d}.", user.getName(), user.getNodeId());
            return this.engine.doAuthenticateQuery(user, null);
        }
        // If the session is unknown or updated, continue.
        String userHex = Hex.encodeHexString(user.getName().getBytes(StandardCharsets.UTF_8));
        String nodeIdHex = Integer.toHexString(user.getNodeId());
        String tokenString = String
                // Junk, to throw people off
                .format(TOKEN_FORMAT, randomHexString(RANDOM_HEX_STRING_LENGTH), randomHexString(RANDOM_HEX_STRING_LENGTH))
                .replace(USER_TMPL, userHex)
                .replace(NODE_TEMPL, nodeIdHex);
        Token token = Token.from(tokenString);
        token = this.engine.doAuthenticateQuery(user, token);
        LOGGER.infof(
                "Created session for {\"%s\", %d} expires at %d.",
                user.getName(),
                user.getNodeId(),
                user.getExpiry()
        );
        return token;
    }

    /**
     * Get the {@link MigrationEngine migration engine}.
     * @return migration engine.
     */
    public MigrationEngine getEngine() {
        return engine;
    }

    /**
     * Revoke the provided user's session.
     * @param user user to revoke session from.
     * @return {@link EngineOperationStatus status}.
     */
    @Override
    public String revoke(final User user) {
        // TODO: broken
        // Expiry has been updated
        if (user == null) {
            return EngineOperationStatus.NOT_FOUND;
        }
        user.update(this);
        // Remove token.
        this
                .engine
                .query(String.format("select * from deauthenticate_user(%s)", user.name))
                .executeAndAwait();
        // Set to zero.
        user.setExpiry(0);
        LOGGER.infof("Revoked session for {\"%s\", %d}", user.getName(), user.getNodeId());
        return EngineOperationStatus.OPERATION_SUCCESS;
    }

    /**
     * Find a user object by a session {@link Token token}.
     * @param session token to search for.
     * @return user object.
     */
    public User findUser(final String session) {
        return this.engine.getSession(session);
    }

    public Optional<ActiveSessionUser> findUser(final User user) {
        if (this.engine.doUserExistsQuery(user)) {
            Token session = this
                    .engine
                    .doAuthenticateQuery(user, null);
            if (session != null) {
                LOGGER.infof("User '%s' exists, found token: %s", user.name, session.token);
                long expiry = this.engine.getExpiry(session);
                User u = User.from(user.getName(), user.getNodeId());
                ActiveSessionUser activeSessionUser = new ActiveSessionUser(u, session);
                activeSessionUser.setExpiry(expiry);
                return Optional.of(activeSessionUser);
            } else {
                LOGGER.infof("Could not find token for %s", user.getName());
            }
        }
        return Optional.empty();
    }

    /**
     * Create a random hex string of the desired length.
     * @param length length of hex string.
     * @return random hex string.
     */
    private static String randomHexString(final int length) {
        String randomString = RandomStringUtils.random(length);
        return Hex.encodeHexString(randomString.getBytes());
    }

    /**
     * The status of an engine operation.
     */
    public static final class EngineOperationStatus {

        /**
         * Operation successful.
         */
        public static final String OPERATION_SUCCESS = "operation successful";

        /**
         * Operation failed.
         */
        public static final String NOT_FOUND = "object not found";

    }

}
