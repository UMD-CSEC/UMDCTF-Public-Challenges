# Possible Futures

*I see possible futures. All at once.*

*Our enemies are all around us.*

*And in so many futures, they prevail.*

*But I do see a way.*

### Hints

Hint 1 (free): The password to each `.7z` file is the MD5 Hash of the name where such `.7z` file is contained.

## Build Instructions

Run `builder.py` in Python 3.12 with `flag.txt` in the same directory.

## Files for CTFd

  +`root.7z`

  +`builder.py`

## Flag

`UMDCTF{th3_w@t3R_0F_l1fE_lE@ds_yOu_t0_v1cT0RY}`

## Writeup

This challenge involves `root.7z`, a compressed archive file formatted into a tree spanning thousands of possible futures.

```
          root.7z
          /      \
         /        \
        /          \
   future_1.7z   future_2.7z
      /  \          /  \
(Flag)   (No flag)     etc..
```

In 11 of of those futures (7z files), a flag is placed in a `.txt` file. All other `.txt` files in this challenge just contain garbage data.
Here are the locations of those flags:
```
possible_flag_3968.txt
possible_flag_5331.txt
possible_flag_12309.txt
possible_flag_13398.txt
possible_flag_13800.txt
possible_flag_17665.txt
possible_flag_22130.txt
possible_flag_25978.txt
possible_flag_26125.txt
possible_flag_27089.txt
possible_flag_27155.txt
```

**Solutions are quite simple - you may either:**

1.) Search all ~35000 subfiles in `root.7z` until you find a flag (slow and not recommended)

2.) Take the `builder.py` script and simply tweak it to show you the closest flag!

### Author Solution (#2)

`root.zip` was generated using python's `random` module which generates pseudo-random numbers. By seeding the random number generator as shown in this line...
```python
random.seed("My name is Paul Muad'dib Atreides, duke of arrakis".encode()) #!!!
```
...we guarantee that each `.7z` file generated by our script will always be the same.

Therefore, we can simply modify `builder.py` to forecast where a flag will be, before we go in and find it! Call our solution `solver.py`:
```python
#solver.py (solver script)

#UMDCTF Challenge: i_see_many_paths
#Developed on Python 3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)] on win32

import string
import random
import hashlib
import py7zr
import os

#===========================================================
#Constants
#===========================================================

#with open("flag.txt", 'r') as f: We can cut this part out
    #FLAG = f.read()
    
MIN_CHILDREN = 1
MAX_CHILDREN = 4

MAX_DEPTH = 10

#For solving: The fact that we seed our random number generator with this specific string means that each ZIP tree generated by builder.py is the same.
#             Therefore, we can just tweak builder.py to know where the flags are.
random.seed("My name is Paul Muad'dib Atreides, duke of arrakis".encode()) #!!!

#===========================================================
#Functions
#===========================================================

COUNT = 0
def get_new_int():
    global COUNT
    COUNT = COUNT + 1
    return COUNT

def random_string(length):
    # Create a random string of the specified length
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

#def create_encrypted_zip(output_filename, files, password):
    #pass #We can also cut this part out

class ZipNode():
    def __init__(self, filename, children, parent): #For solving: Add parent reference to each node so we can lookup the path to a flag
        self.filename = filename
        self.children = children
        self.parent = parent
        self.password = hashlib.md5(filename.encode()).hexdigest()

    def __str__(self):
        return "Name: {}".format(self.filename)

#For solving: Keep all of this as-is
def generate_random_tree(root, depth):
    if (depth >= MAX_DEPTH):
        return

    if (depth >= MAX_DEPTH * (3 / 4)):
        root.children.append(ZipNode("possible_flag_{}.txt".format(get_new_int()), [], root))

    for i in range(MIN_CHILDREN, random.randint(MIN_CHILDREN, MAX_CHILDREN) + 1):
        child = ZipNode("future_number_{}.7z".format(get_new_int()), [], root)

        root.children.append(child)

        generate_random_tree(child, depth + 1)

#For solving: Crudely modify this function to show us the branch structure to the first flag generated. 
def tree_to_zip_file(root):
    for child in root.children:
        if (child.filename[-3:] == "txt"):
            if (random.random() < 0.0005):
                return_to_root(child)
            else:
                random_string(random.randint(5, 35)) #For solving: We cannot drop any random module calls since that will affect the output. We generate a random string just to maintain keep the PRNG in the right state.
            
            #open(child.filename, 'w+').write(FLAG if (random.random() < 0.0005) else random_string(random.randint(5, 35)))
        else:
            tree_to_zip_file(child)

    #create_encrypted_zip(root.filename, root.children, root.password)

#For solving: Add this simple utility function to show us where the first flag is
def return_to_root(child):
    if (child.filename == "root.7z"):
        print("(root.7z)")
        input("Press any key to EXIT")
        exit()
    
    print("{} | Password to subfiles: {}".format(child, child.password))
    return_to_root(child.parent)

#===========================================================
#Entry Point
#===========================================================

print("Location of a flag to root.7z:")

root = ZipNode("root.7z", [], None)

generate_random_tree(root, 0)
tree_to_zip_file(root)
```

Running this script in `Python 3.12` (the version where this challenge was built), we will immediately get the location of a flag:

```
#Output of solver.py
Location of a flag to root.7z:
Name: possible_flag_3968.txt | Password to subfiles: 65325db7c48ba97bb786776e86da865a
Name: future_number_3967.7z | Password to subfiles: aecf605ce2d90410ea4fae817c32beff
Name: future_number_3953.7z | Password to subfiles: 5f10d6b15ac51d92cc66b2722cfc9165
Name: future_number_3908.7z | Password to subfiles: 8a2466a92aa8799d910d31bd3f0aeb7b
Name: future_number_3765.7z | Password to subfiles: 03fbdfc816aab8d0b6961996e4357cfd
Name: future_number_3764.7z | Password to subfiles: 790abec6791f365229a3fe0145e2aa7d
Name: future_number_3763.7z | Password to subfiles: a5c48564fe7a57028dd3e55e78b47eb0
Name: future_number_3762.7z | Password to subfiles: 6bf23d1186bad11c56c59518713b0c4c
Name: future_number_3761.7z | Password to subfiles: 81ad1418ccb7b9ca74ce6f4599bfdd48
(root.7z)
Press any key to EXIT
```

Using this script in other Python versions may result in wrong answers. Make sure you are using `Python 3.12`!
