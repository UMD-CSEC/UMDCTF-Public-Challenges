#solver.py (solver script)

#UMDCTF Challenge: i_see_many_paths
#Developed on Python 3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)] on win32

import string
import random
import hashlib
import py7zr
import os

#===========================================================
#Constants
#===========================================================

#with open("flag.txt", 'r') as f: We can cut this part out
    #FLAG = f.read()
    
MIN_CHILDREN = 1
MAX_CHILDREN = 4

MAX_DEPTH = 10

#For solving: The fact that we seed our random number generator with this specific string means that each ZIP tree generated by builder.py is the same.
#             Therefore, we can just tweak builder.py to know where the flags are.
random.seed("My name is Paul Muad'dib Atreides, duke of arrakis".encode()) #!!!

#===========================================================
#Functions
#===========================================================

COUNT = 0
def get_new_int():
    global COUNT
    COUNT = COUNT + 1
    return COUNT

def random_string(length):
    # Create a random string of the specified length
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

#def create_encrypted_zip(output_filename, files, password):
    #pass #We can also cut this part out

class ZipNode():
    def __init__(self, filename, children, parent): #For solving: Add parent reference to each node so we can lookup the path to a flag
        self.filename = filename
        self.children = children
        self.parent = parent
        self.password = hashlib.md5(filename.encode()).hexdigest()

    def __str__(self):
        return "Name: {}".format(self.filename)

#For solving: Keep all of this as-is
def generate_random_tree(root, depth):
    if (depth >= MAX_DEPTH):
        return

    if (depth >= MAX_DEPTH * (3 / 4)):
        root.children.append(ZipNode("possible_flag_{}.txt".format(get_new_int()), [], root))

    for i in range(MIN_CHILDREN, random.randint(MIN_CHILDREN, MAX_CHILDREN) + 1):
        child = ZipNode("future_number_{}.7z".format(get_new_int()), [], root)

        root.children.append(child)

        generate_random_tree(child, depth + 1)

#For solving: Crudely modify this function to show us the branch structure to the first flag generated. 
def tree_to_zip_file(root):
    for child in root.children:
        if (child.filename[-3:] == "txt"):
            if (random.random() < 0.0005):
                return_to_root(child)
            else:
                random_string(random.randint(5, 35)) #For solving: We cannot drop any random module calls since that will affect the output. We generate a random string just to maintain keep the PRNG in the right state.
            
            #open(child.filename, 'w+').write(FLAG if (random.random() < 0.0005) else random_string(random.randint(5, 35)))
        else:
            tree_to_zip_file(child)

    #create_encrypted_zip(root.filename, root.children, root.password)

#For solving: Add this simple utility function to show us where the first flag is
def return_to_root(child):
    if (child.filename == "root.7z"):
        print("(root.7z)")
        input("Press any key to EXIT")
        exit()
    
    print("{} | Password to subfiles: {}".format(child, child.password))
    return_to_root(child.parent)

#===========================================================
#Entry Point
#===========================================================

print("Location of a flag to root.7z:")

root = ZipNode("root.7z", [], None)

generate_random_tree(root, 0)
tree_to_zip_file(root)




    
